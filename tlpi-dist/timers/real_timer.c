/* real_timer.c

   A demonstration of the use of (real-time) timers created using setitimer().

   Usage: real_timer [secs [usecs [int-secs [int-usecs]]]]
             Defaults: 2      0        0         0

   The command-line arguments are the second and microsecond settings for
   the timer's initial value and interval.

   The version of this code shown in the first print of the book contained
   an error in the main() function whereby 'maxSigs' was initialized before
   'itv', even though the initialization of the former variable depends on the
   initialization of the latter variable. See the erratum for page 983 to 984.
*/

#include <signal.h>
#include <sys/time.h>
#include <time.h>
#include "tlpi_hdr.h"

// `sig_atomic_t` is like int, but can be used in context of signal handler.
// `volatile` indicates to the compiler that it shouldn't attempt to optimize
// said variable. Its important to use `volatile` with `sig_atomic_t`.
static volatile sig_atomic_t gotAlarm = 0;

// static function is only visible in file where declared.
static void
displayTimes(const char *msg, Boolean includeTimer)
{
    struct itimerval itv;
    // static variables are statically allocated, while having the same scope as
    // automatic local variables. When we call this function again, the values
    // of all static variables will be preserved from the previous function
    // call.
    static struct timeval start;
    struct timeval curr;
    static int callNum = 0;

    if (callNum == 0) {
        // Init elapsed time meter.
        if (gettimeofday(&start, NULL) == -1)
            errExit("gettimeofday");
    }

    // Print header every 20 lines
    if (callNum % 20 == 0)
        printf("    Elapsed Value Interval\n");

    if (gettimeofday(&curr, NULL) == -1)
        errExit("gettimeofday");
    printf("%-7s %6.2f", msg, curr.tv_sec - start.tv_sec +
                        (curr.tv_usec - start.tv_usec) / 1000000.0);

    if (includeTimer) {
        if (getitimer(ITIMER_REAL, &itv) == -1)
            errExit("getitimer");
        printf("  %6.2f  %6.2f",
                itv.it_value.tv_sec + itv.it_value.tv_usec / 1000000.0,
                itv.it_interval.tv_sec + itv.it_interval.tv_usec / 1000000.0);
    }

    printf("\n");
    callNum++;
}

static void
sigalrmHandler(int sig)
{
    gotAlarm = 1;
}

int
main(int argc, char *argv[])
{
    struct itimerval itv;
    clock_t prevClock;
    int maxSigs;
    int sigCnt = 0;
    struct sigaction sa;

    if (argc > 1 && strcmp(argv[1], "--help") == 0)
        usageErr("%s [secs [usecs [int-secs [int-usecs]]]]\n", argv[0]);

    // Set up sighandler for the `SIGALARM` signal generated by the timer
    // expiration.
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigalrmHandler;
    if (sigaction(SIGALRM, &sa, NULL) == -1)
        errExit("sigaction");

    /* Set timer from the command-line arguments */

    itv.it_value.tv_sec = (argc > 1) ? getLong(argv[1], 0, "secs") : 2;
    itv.it_value.tv_usec = (argc > 2) ? getLong(argv[2], 0, "usecs") : 0;
    itv.it_interval.tv_sec = (argc > 3) ? getLong(argv[3], 0, "int-secs") : 0;
    itv.it_interval.tv_usec = (argc > 4) ? getLong(argv[4], 0, "int-usecs") : 0;

    maxSigs = (itv.it_interval.tv_sec == 0 && itv.it_interval.tv_sec == 0) ? 1 : 3;

    displayTimes("START:", FALSE);

    // Create timer - `real` timer uses the wallclock.
    if (setitimer(ITIMER_REAL, &itv, NULL) == -1)
        errExit("setitimer");

    // `clock` returns an approximation of processor time.
    prevClock = clock();

    for (;;) {
        // Inner loop consumes at least 0.5 seconds CPU time...
        while(((clock() - prevClock) * 10 / CLOCKS_PER_SEC) < 5) {
            // gotAlarm is set by the signal handler.
            if (gotAlarm) {
                gotAlarm = 0;
                displayTimes("ALARM:", TRUE);

                sigCnt++;
                if (sigCnt >= maxSigs) {
                    printf("That's all\n");
                    exit(EXIT_SUCCESS);
                }
            }
        }

        prevClock = clock();
        displayTimes("Main: ", TRUE);
    }
}
